# Um Caso Complexo

**Imagine esses passos para realizar um teste:**

1. Execute a suÃ­te de **Testes UnitÃ¡rios** em paralelo
2. Limpe e popule o banco de dados
3. Verifique a suÃ­te de **IntegraÃ§Ã£o de Sucessos Esperados** sequencialmente
4. Limpe e popule o banco de dados â€” novamente
5. Verifique a suÃ­te de **IntegraÃ§Ã£o de Falhas Esperadas** sequencialmente

**Requisitos:**

Cada passo requer sucesso para ser processado.

**Estrutura de DiretÃ³rios:**

```bash
â”œâ”€â”€ .
â”œâ”€â”€ test
â”‚ â”œâ”€â”€ unit
â”‚ â”œâ”€â”€ integration
â”‚ â”‚ â”œâ”€â”€ successes
â”‚ â”‚ â”‚ â””â”€â”€ **/.spec.js
â”‚ â”‚ â””â”€â”€ failures
â”‚ â”‚   â””â”€â”€ **/.spec.js
â”‚ â”œâ”€ run.test.js # O executor
â”‚ â”œâ”€ tools.test.js
```

> NÃ³s realmente precisamos complicar ainda mais as coisas criando executores de testes avanÃ§ados para rodar nossos testes jÃ¡ complexos? ðŸ˜…

### SoluÃ§Ã£o do Poku âœ¨

```ts
import { poku, assert } from 'poku';
import { recreateDatabase } from './tools.test.js';

const unitCode = await poku('test/unit', {
  parallel: true,
  noExit: true,
});

assert.strictEqual(0, unitCode, 'Executando Testes UnitÃ¡rios');

await assert.doesNotReject(
  recreateDatabase(),
  'Preparando o banco de dados para os Testes de IntegraÃ§Ã£o de Sucessos'
);

const successesCode = await poku('test/integration/successes', {
  noExit: true,
});

assert.strictEqual(
  0,
  successesCode,
  'Executando Testes de IntegraÃ§Ã£o de Sucessos'
);

await assert.doesNotReject(
  recreateDatabase(),
  'Preparando o banco de dados para os Testes de IntegraÃ§Ã£o de Sucessos'
);

const failuresCode = await poku('test/integration/failures', {
  noExit: true,
});

assert.strictEqual(
  0,
  failuresCode,
  'Executando Testes de IntegraÃ§Ã£o de Falhas'
);
```

> Por quÃª comentar o cÃ³digo se podemos fazer melhor? ðŸ§™ðŸ»

**Finalmente**

```bash
npx poku test/run.test.js
```

> Ou `npx poku test/run.test.ts` para **TypeScript**.
