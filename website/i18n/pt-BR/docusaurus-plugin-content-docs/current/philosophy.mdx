import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Filosofia

A filosofia do **Poku** se concentra na simplicidade e na eficiÃªncia, removendo complexidades e padrÃµes para tornar os testes acessÃ­veis desde os projetos mais simples atÃ© os mais complexos.

<hr />

## EssÃªncia do JavaScript para testes ğŸ’¡ {#javascript-essence-for-tests-}

> A sintaxe nativa do **JavaScript** para testes Ã© o que torna possÃ­vel usar o **Poku** em vÃ¡rias plataformas.

Imagine que vocÃª quer executar funÃ§Ãµes assÃ­ncronas, em que uma Ã© executada apÃ³s a outra, e exibir uma mensagem no inÃ­cio e no final da execuÃ§Ã£o:

```ts
console.log('Iniciado');

await funcA();
await funcB();

console.log('Finalizado');
```

Normalmente, nÃ£o Ã© possÃ­vel fazer isso com a maioria dos executores de teste.
Veja este exemplo fictÃ­cio:

> Um termo popular para isso Ã© â€œboilerplateâ€, que sÃ£o requisitos extras para estruturar e configurar os testes.

```ts
describe('Meu Teste', { concurrency: 1 }, () => {
  // VocÃª precisa declarar explicitamente o que deve ser executado antes dos testes
  beforeAll(() => {
    console.log('Iniciado');
  });

  // A Ãºltima etapa do script Ã© chamada antes dos prÃ³prios testes
  afterAll(() => {
    console.log('Finalizado');
  });

  // Testes assÃ­ncronos, mas eles serÃ£o executados sequencialmente mesmo sem o uso do `await`
  it(async () => {
    // teste assÃ­ncrono
  });

  it(async () => {
    // teste assÃ­ncrono
  });
});
```

AlÃ©m disso, nÃ£o Ã© possÃ­vel executÃ¡-lo como `node test.js` devido a _evaluations_, estado global ou transformaÃ§Ãµes de testes, sendo necessÃ¡rio rodar seu teste usando o executor de teste.

O **Poku** traz de volta a essÃªncia do **JavaScript** aos testes:

```ts
import { describe, it } from 'poku';

describe('Meu Teste', async () => {
  console.log('Iniciado');

  await it(async () => {
    // teste assÃ­ncrono
  });

  await it(async () => {
    // teste assÃ­ncrono
  });

  console.log('Finalizado');
});
```

:::tip

O **Poku** nÃ£o utiliza um estado global, permitindo que vocÃª o use como e onde quiser:

<Tabs>
  <TabItem default value='Node.js + Poku'>

```bash
npx poku test.js
```

  </TabItem>
  <TabItem default value='Bun + Poku'>

```bash
bun poku test.js
```

  </TabItem>
  <TabItem default value='Deno + Poku'>

```bash
deno run npm:poku test.js
```

  </TabItem>
  <TabItem default value='Node.js'>

```bash
node test.js
```

  </TabItem>
  <TabItem default value='Bun'>

```bash
bun test.js
```

  </TabItem>
  <TabItem default value='Deno'>

```bash
deno run test.js
```

  </TabItem>
  <TabItem default value='Yarn + Poku'>

```bash
yarn poku test.js
```

  </TabItem>
  <TabItem default value='pnpm + Poku'>

```bash
pnpm poku test.js
```

  </TabItem>
</Tabs>

- A mesma ideia para o **TypeScript**.

:::

<hr />

## Tornando os testes realmente fÃ¡ceis ğŸŒ±

Em muitos casos, os testes levam ao mesmo objetivo comum: a verificaÃ§Ã£o de um valor esperado com um valor dinÃ¢mico.

Mas os testes geralmente nÃ£o mostram logs e detalhes suficientes se vocÃª se concentrar apenas na verificaÃ§Ã£o de valores. Mesmo que funcionem, vocÃª pode facilmente encontrar uma mensagem de erro como "pelo menos um teste Ã© necessÃ¡rio" com alguns executores de testes.

Um exemplo usando o `assert` nativo do **Node.js**:

```ts
import assert from 'node:assert';

const one = 1;
assert.equal(one, 1, '1 precisa ser igual a 1');
```

- A mensagem neste exemplo nÃ£o serÃ¡ exibida e o teste passarÃ¡ silenciosamente.

Em vez disso, vocÃª precisarÃ¡ usar `test` ou `describe` e `it`:

```ts
import assert from 'node:assert';
import test from 'node:test';

test('one Ã© igual a 1', () => {
  const one = 1;
  assert.equal(one, 1, '1 precisa ser igual a 1');
});
```

O **Poku** permite que um teste siga a abordagem **BDD**/**TDD** usando apenas o mÃ©todo `assert`:

> âš ï¸ _Por favor, isso nÃ£o Ã© uma recomendaÃ§Ã£o, mas sim, seria possÃ­vel para testes mais simples._

<Tabs>
  <TabItem default value='test/file.test.mjs'>

```ts
import { assert } from 'poku';

const one = 1;
assert.equal(one, 1, 'one Ã© igual a 1');
```

  </TabItem>
</Tabs>

EntÃ£o:

<Tabs>
  <TabItem default value='Node.js and TypeScript (Node.js)'>

```bash
npx poku
```

  </TabItem>
  <TabItem  value='Bun'>

```bash
bun poku
```

  </TabItem>
  <TabItem  value='Deno'>

```bash
deno run npm:poku
```

  </TabItem>
</Tabs>

:::info
Isso irÃ¡ gerar um log completo, tanto em caso de sucesso quanto de falha, mantendo o estilo exato de desenvolvimento do **Node.js** e sendo compatÃ­vel com **Node.js**, **Bun** e **Deno**.
:::

:::tip
Cada caso pode ser diferente. Para isso, o **Poku** possui uma forma completamente modular de uso, permitindo que vocÃª utilize `test`, `describe`, `it`, `beforeEach`, `afterEach`, o modo `--watch` e mais, de acordo com suas necessidades para testes mais complexos ou testes que seguem um padrÃ£o especÃ­fico.
:::

<hr />

## Funcionalidades especiais ğŸ’«

O **Poku** oferece suporte integrado para desafios comuns de teste, como iniciar serviÃ§os, servidores e contÃªineres necessÃ¡rios para executar testes e encerrÃ¡-los no final dos testes, alÃ©m de flexibilidade para lidar com portas e processos.

<hr />

## Prioridades de desenvolvimento ğŸ”§

- Uso amigÃ¡vel para humanos.
- Compatibilidade entre plataformas (**Node**, **Bun**, e **Deno**).
- Melhorias no desempenho.
- Todas as funcionalidades devem ser documentadas e ter pelo menos um exemplo mÃ­nimo de uso.

> Compatibilidade com ambientes legados sempre que possÃ­vel, documentando quando um recurso especÃ­fico funciona apenas a partir de uma versÃ£o do runtime/plataforma.

<hr />

## Por que nÃ£o instalar dependÃªncias externas? ğŸ“¦

> Por ordem de relevÃ¢ncia

1. Exigindo que todas as dependÃªncias possÃ­veis sejam totalmente compatÃ­veis com **Node.js**, **Bun** e **Deno**.
2. Para manter o tamanho final da instalaÃ§Ã£o o mais leve possÃ­vel.
3. Para evitar problemas de compatibilidade com ambientes legados.

### TypeScript

Para **Node.js** + **TypeScript**, o Poku usa [**tsx**](https://github.com/privatenumber/tsx) para executar os arquivos.
Por que? Porque segue o mesmo princÃ­pio do **Poku**: zero configuraÃ§Ãµes para necessidades comuns.

<hr />

## Por que manter a compatibilidade com versÃµes anteriores? ğŸ‘´ğŸ¼

VÃ¡rios projetos ainda utilizam ou oferecem suporte a versÃµes legadas. O requisito para versÃµes legadas nÃ£o Ã© uma regra rÃ­gida e pode mudar com as versÃµes major devido a recursos especÃ­ficos que podem exigir polyfills e afetar diretamente o desempenho.

Por isso, o limite escolhido foi a versÃ£o `16.x.x` do **Node.js**.

:::note
**Poku** sempre recomenda o uso de versÃµes compatÃ­veis de cada runtime.
:::

<hr />

## Planos futuros ğŸ“†

Embora nÃ£o seja uma prioridade, hÃ¡ planos para integrar os seguintes recursos ao **Poku**:

- **Stub**
- **Mock**
- **Spies**

> Veja exemplos de **mock** para [**CJS**](/docs/examples/mock/cjs) e [**ESM**](/docs/examples/mock/esm) usando **Poku** + [**quibble**](https://github.com/testdouble/quibble).

<hr />

## Controle de versÃ£o ğŸ·ï¸

Elas nÃ£o sÃ£o consideradas breaking changes:

- AlteraÃ§Ãµes de formataÃ§Ã£o e estilo nos resultados.
- Novas funcionalidades nÃ£o crÃ­ticas que dependem de uma versÃ£o especÃ­fica da plataforma.
  - As long as it doesn't affect basic usability.
- Se um recurso nÃ£o for mais Ãºtil devido a uma nova abordagem _(as long as it doesn't affect the end user)_.
- AlteraÃ§Ãµes no schema do intellisense do _JSON_ _(arquivos de configuraÃ§Ã£o)_.

<hr />

## O que o Poku nÃ£o se propÃµe a ser ğŸ¤šğŸ»

- Um substituto para executores de teste nativos
  - Tente usar o **Poku** como uma alternativa ğŸ·
- O mais leve ou o mais rÃ¡pido
  - Embora esses pontos sejam considerados, o principal objetivo Ã© manter um equilÃ­brio entre boas prÃ¡ticas.

:::danger
Observe que o **Poku** tem uma maneira diferente de ser usado, inspirada inteiramente na essÃªncia do JavaScript nativo, o que pode ser tanto uma vantagem quanto uma desvantagem para aqueles que estÃ£o acostumados com os _hooks_ tradicionais de outros executores de teste.
:::
