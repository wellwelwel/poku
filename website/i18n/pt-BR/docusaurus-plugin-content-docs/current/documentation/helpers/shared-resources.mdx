---
sidebar_position: 11
tags: [shared, state, resources, e2e, integration]
---

import { History } from '@site/src/components/History';
import { Stability } from '@site/src/components/Stability';

# ðŸª¢ Recursos Compartilhados

<History
  records={[
    {
      version: '3.0.3-canary.60ff5ce2',
      changes: [<>Introduce Shared Resources.</>],
    },
  ]}
/>

<Stability level={1} />

Compartilhe estado e mÃ©todos entre arquivos e processos de teste, permitindo padrÃµes avanÃ§ados de integraÃ§Ã£o e testes end-to-end.

## O que sÃ£o Recursos Compartilhados?

**Recursos Compartilhados** permitem que vocÃª defina um recurso (objeto, estado ou API) em um Ãºnico arquivo e acesse ou altere esse recurso a partir de mÃºltiplos arquivos ou processos de teste. Isso Ã© Ãºtil para cenÃ¡rios como:

- Compartilhar uma conexÃ£o de banco de dados ou armazenamento em memÃ³ria.
- Coordenar estado entre testes paralelos ou sequenciais.
- Implementar lÃ³gica de setup/teardown entre arquivos.

## Uso BÃ¡sico

### 1. Defina um Recurso Compartilhado

Crie um arquivo `.resource.ts` e exporte um recurso compartilhado usando `createSharedResource`:

```ts
import { createSharedResource } from 'poku';

export default createSharedResource('sharedCounter', () => {
  let count = 0;
  return {
    getCount: () => count,
    increment: () => ++count,
    reset: () => {
      count = 0;
    },
  };
});
```

### 2. Acesse o Recurso Compartilhado nos Testes

Use `getSharedResource` em qualquer arquivo de teste para acessar e chamar mÃ©todos do recurso compartilhado:

```ts
import { getSharedResource, test, assert } from 'poku';

test('incrementa o contador', async () => {
  const [counter, detach] = await getSharedResource('sharedCounter');
  await counter.increment();
  assert.equal(await counter.getCount(), 1);
  detach();
});
```

### 3. MÃ©todos se Tornam Chamadas de Procedimento Remoto

Todas as funÃ§Ãµes do seu recurso se tornam chamadas de procedimento remoto (RPCs), entÃ£o vocÃª pode alterar ou ler o estado compartilhado com seguranÃ§a entre processos.

Ã‰ importante notar que os argumentos sÃ£o serializados usando [Advanced Serialization](https://nodejs.org/api/child_process.html#advanced-serialization)
durante a comunicaÃ§Ã£o entre diferentes processos, o que significa que alguns tipos complexos (como funÃ§Ãµes) nÃ£o sÃ£o suportados neste momento.

### 4. Desanexando o Recurso

Quando vocÃª chama `getSharedResource`, ele retorna uma tupla com o recurso e uma funÃ§Ã£o `detach`.
**Ã‰ essencial sempre chamar `detach` ao final do seu teste**: isso cancela a inscriÃ§Ã£o do seu processo de teste
nas atualizaÃ§Ãµes do recurso compartilhado, garantindo a limpeza adequada e prevenindo vazamentos de memÃ³ria.
Se vocÃª nÃ£o chamar `detach`, seu processo permanecerÃ¡ inscrito, o que pode levar a vazamentos de recursos,
uso desnecessÃ¡rio de memÃ³ria e problemas de isolamento de testes. Ao sempre chamar `detach`, vocÃª mantÃ©m
seu ambiente de teste limpo, previsÃ­vel e livre de efeitos colaterais causados por inscriÃ§Ãµes remanescentes.

```ts
test('desanexa o recurso', async () => {
  const [counter, detach] = await getSharedResource('sharedCounter');
  await counter.increment();
  assert.equal(await counter.getCount(), 1);
  detach(); // Limpa o recurso
});
```

### 5. LÃ³gica de Limpeza

VocÃª pode definir uma funÃ§Ã£o de limpeza ao criar o recurso. Ela serÃ¡ chamada quando o recurso nÃ£o for mais necessÃ¡rio:

```ts
export default createSharedResource(
  'sharedCounter',
  () => {
    let count = 0;
    return {
      getCount: () => count,
      increment: () => ++count,
      reset: () => {
        count = 0;
      },
    };
  },
  (resource) => {
    // LÃ³gica de limpeza
    resource.reset();
  }
);
```

## Exemplos do Mundo Real

### 1. Cache LRU Compartilhado (`lru.min`)

Compartilhe um cache LRU em memÃ³ria entre testes:

**lru.resource.ts**

```ts
import { createSharedResource } from 'poku';
import { createLRU } from 'lru.min';

export default createSharedResource('lru', () => {
  const cache = createLRU({ max: 3 });
  return cache;
});
```

**cache.test.ts**

```ts
import { getSharedResource, test, assert } from 'poku';

test('pode compartilhar cache', async () => {
  const [cache, detach] = await getSharedResource('lru');
  await cache.set('foo', 123);
  assert((await cache.get('foo')) === 123);
  detach();
});
```

---

### 2. ConexÃ£o MySQL Compartilhada (`mysql2`)

Compartilhe uma Ãºnica conexÃ£o MySQL entre testes:

**mysql.resource.ts**

```ts
import { createSharedResource } from 'poku';
import mysql from 'mysql2/promise';

export default createSharedResource(
  'mysql',
  async () => {
    const connection = await mysql.createConnection({
      host: 'localhost',
      user: 'root',
      database: 'test',
    });
    return connection;
  },
  (connection) => {
    // FunÃ§Ã£o de limpeza para fechar a conexÃ£o
    return connection.destroy();
  }
);
```

**db.test.ts**

```ts
import { getSharedResource, test, assert } from 'poku';

test('pode consultar usuÃ¡rios', async () => {
  const [db, detach] = await getSharedResource('mysql');
  const [rows] = await db.query('SELECT * FROM users LIMIT 10');

  assert(Array.isArray(rows));
  assert.equal(rows.length, 10);
  detach();
});
```
